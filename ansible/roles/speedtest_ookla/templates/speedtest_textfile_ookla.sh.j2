#!/usr/bin/env bash
set -euo pipefail

# === Параметры окружения / шаблона ===
TEXTDIR="{{ node_speedtest_textdir }}"
TMP="$(mktemp "${TEXTDIR}/.speedtest.prom.XXXXXX")"
OUT="${TEXTDIR}/speedtest_ookla.prom"
trap 'rm -f "$TMP"' EXIT

# Имя узла должно совпадать с labels.name в job=node (для фильтрации в Grafana)
NODE_NAME="${NODE_NAME:-{{ node_speedtest_node_name }}}"

# Опционально: фиксированный сервер Ookla (узнать: `speedtest -L`)
SPEEDTEST_SERVER_ID="${SPEEDTEST_SERVER_ID:-{{ node_speedtest_server_id }}}"
SPEEDTEST_BIN="${SPEEDTEST_BIN:-{{ node_speedtest_bin }}}"

# Логика «не грузить uplink, если он занят»
SKIP_BUSY="${SKIP_BUSY:-{{ node_speedtest_skip_busy | ternary('true','false') }}}"
BUSY_THRESH="${BUSY_THRESH:-{{ node_speedtest_busy_thresh }}}"

# Для запроса к Prometheus (если хотим проверять «занятость»)
PROM_URL="${PROM_URL:-{{ node_speedtest_prom_url }}}"
PROM_USER="${PROM_USER:-{{ node_speedtest_prom_user }}}"
PROM_PASS="${PROM_PASS:-{{ node_speedtest_prom_pass }}}"
IS_BUSY_DEBUG=${IS_BUSY_DEBUG:-{{ node_speedtest_is_busy_debug }}}

# === Функции-помощники ===

# Проверка «занятости» uplink по агрегату метрики
is_busy() {
  local q='max_over_time(node:uplink_utilization:ratio{name="'"$NODE_NAME"'"}[1m])'
  local curl_args=(-sG "$PROM_URL/api/v1/query" --data-urlencode "query=$q")
  if [[ -n "${PROM_USER:-}" ]]; then
    curl_args=(-s -u "$PROM_USER:$PROM_PASS" -G "$PROM_URL/api/v1/query" --data-urlencode "query=$q")
  fi

  if [[ "${IS_BUSY_DEBUG:-0}" = "1" ]]; then
    local auth_mask=""; [[ -n "${PROM_USER:-}" ]] && auth_mask=" -u ${PROM_USER}:********"
    echo "[is_busy] PROM_URL=${PROM_URL}${auth_mask}"
    echo "[is_busy] QUERY=${q}"
  fi

  local resp v
  resp="$(curl "${curl_args[@]}")" || true
  v="$(printf '%s' "$resp" | jq -r '.data.result[0].value[1] // empty' 2>/dev/null || true)"

  if [[ "${IS_BUSY_DEBUG:-0}" = "1" ]]; then
    if command -v jq >/dev/null 2>&1; then
      echo "[is_busy] RAW_RESPONSE:"; printf '%s\n' "$resp" | jq .
    else
      echo "[is_busy] RAW_RESPONSE: $resp"
    fi
    echo "[is_busy] parsed_value=${v:-<empty>}  threshold=${BUSY_THRESH:-0.50}"
  fi

  # Возвращает 0 (busy) если v > threshold
  awk -v th="${BUSY_THRESH:-0.50}" -v x="${v:-0}" 'BEGIN{exit !(x>th)}'
}

# Экранирование значений лейблов для Prometheus exposition формат
prom_escape() { sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'; }

# Конверторы единиц для выходных метрик
to_bps_from_Bps() { awk '{printf("%.0f",$1*8)}'; }     # bytes/s → bits/s
to_sec_from_ms()  { awk '{printf("%.6f",$1/1000)}'; }  # ms → s
to_ratio_from_pct(){ awk '{printf("%.6f",$1/100)}'; }  # % → ratio

# === Предполётные проверки ===

if [[ ! -x "$SPEEDTEST_BIN" ]]; then
  echo "# ookla speedtest CLI not found at $SPEEDTEST_BIN" >>"$TMP"
  install -m 0644 -T "$TMP" "$OUT"
  exit 0
fi

if [[ "$SKIP_BUSY" == "true" ]] && is_busy; then
  {
    echo "# skipped due to high uplink utilization"
    printf 'vpn_speed_last_run_timestamp_seconds{name="%s",method="ookla"} %s\n' "$NODE_NAME" "$(date +%s)"
    printf 'vpn_speed_success{name="%s",method="ookla"} 0\n' "$NODE_NAME"
  } >>"$TMP"
  install -m 0644 -T "$TMP" "$OUT"
  exit 0
fi

LANG=C LC_ALL=C

# === Запуск speedtest CLI ===

ARGS=( --accept-license --accept-gdpr --format=json --progress=no )
# Корректно добавляем server-id, если указан (поддержка длинного/короткого флага в разных бинарях)
if [[ -n "${SPEEDTEST_SERVER_ID:-}" ]]; then
  if "$SPEEDTEST_BIN" --help 2>&1 | grep -q -- '--server-id'; then
    ARGS+=( --server-id "$SPEEDTEST_SERVER_ID" )
  else
    ARGS+=( -s "$SPEEDTEST_SERVER_ID" )
  fi
fi

# Собираем сырой вывод (включая лог-строки от Ookla)
RAW="$("$SPEEDTEST_BIN" "${ARGS[@]}" 2>&1 || true)"
CLEAN="$(printf '%s' "$RAW" | tr -d '\r')"

# Из потока JSON-строк пытаемся взять именно объект с "type":"result"
JSON="$(printf '%s\n' "$CLEAN" | jq -c 'select(.type=="result")' 2>/dev/null | tail -n1 || true)"
# Фолбэк: первая строка, похожая на JSON-объект
if [[ -z "$JSON" ]]; then
  JSON="$(printf '%s\n' "$CLEAN" | grep -m1 '^{' || true)"
fi

# Если JSON пустой/невалиден — мягкий фолбэк
if [[ -z "$JSON" ]] || ! printf '%s' "$JSON" | jq -e . >/dev/null 2>&1; then
  NOW="$(date +%s)"
  {
    echo "# speedtest json parse failed"
    printf '# raw_head: %s\n' "$(printf '%s' "$CLEAN" | head -c 300 | tr '\n' ' ')"
    printf 'vpn_speed_last_run_timestamp_seconds{name="%s",method="ookla"} %s\n' "$NODE_NAME" "$NOW"
    printf 'vpn_speed_success{name="%s",method="ookla"} 0\n' "$NODE_NAME"
  } >>"$TMP"
  install -m 0644 -T "$TMP" "$OUT"
  exit 0
fi

# === Парсинг интересующих полей ===
# Берём скорость в BYTES/сек: при наличии bitsPerSecond делим её на 8, иначе используем bandwidth/bytesPerSecond как есть.
dl_Bps="$(jq -r '(.download.bandwidth // .download.bytesPerSecond // (.download.bitsPerSecond? / 8)) // empty | select(.!=null)' <<<"$JSON")"
ul_Bps="$(jq -r '(.upload.bandwidth   // .upload.bytesPerSecond   // (.upload.bitsPerSecond?   / 8)) // empty | select(.!=null)' <<<"$JSON")"

ping_ms="$(jq -r '.ping.latency // empty | select(.!=null)' <<<"$JSON")"
jitter_ms="$(jq -r '.ping.jitter  // empty | select(.!=null)' <<<"$JSON")"
loss_pct="$(jq -r '.packetLoss    // empty | select(.!=null)' <<<"$JSON")"

srv_name="$(jq -r '.server.name     // empty | select(.!=null)' <<<"$JSON" | prom_escape)"
srv_loc="$(jq -r '.server.location  // empty | select(.!=null)' <<<"$JSON" | prom_escape)"
srv_id="$(jq -r  '.server.id        // empty | select(.!=null)' <<<"$JSON")"
res_url="$(jq -r '.result.url       // empty | select(.!=null)' <<<"$JSON" | prom_escape)"

# === Формирование метрик в текстовый файл ===
NOW="$(date +%s)"
{
  printf 'vpn_speed_last_run_timestamp_seconds{name="%s",method="ookla"} %s\n' "$NODE_NAME" "$NOW"

  if [[ -n "${ping_ms:-}" ]]; then
    printf 'vpn_speed_ping_seconds{name="%s",method="ookla",server="%s",server_location="%s",server_id="%s"} %s\n' \
      "$NODE_NAME" "$srv_name" "$srv_loc" "$srv_id" "$(to_sec_from_ms <<<"$ping_ms")"
  fi

  if [[ -n "${jitter_ms:-}" ]]; then
    printf 'vpn_speed_jitter_seconds{name="%s",method="ookla",server="%s",server_location="%s",server_id="%s"} %s\n' \
      "$NODE_NAME" "$srv_name" "$srv_loc" "$srv_id" "$(to_sec_from_ms <<<"$jitter_ms")"
  fi

  if [[ -n "${loss_pct:-}" ]]; then
    printf 'vpn_speed_packet_loss_ratio{name="%s",method="ookla",server="%s",server_location="%s",server_id="%s"} %s\n' \
      "$NODE_NAME" "$srv_name" "$srv_loc" "$srv_id" "$(to_ratio_from_pct <<<"$loss_pct")"
  fi

  if [[ -n "${dl_Bps:-}" ]]; then
    printf 'vpn_speed_download_bps{name="%s",method="ookla",server="%s",server_location="%s",server_id="%s"} %s\n' \
      "$NODE_NAME" "$srv_name" "$srv_loc" "$srv_id" "$(to_bps_from_Bps <<<"$dl_Bps")"
  fi

  if [[ -n "${ul_Bps:-}" ]]; then
    printf 'vpn_speed_upload_bps{name="%s",method="ookla",server="%s",server_location="%s",server_id="%s"} %s\n' \
      "$NODE_NAME" "$srv_name" "$srv_loc" "$srv_id" "$(to_bps_from_Bps <<<"$ul_Bps")"
  fi

  if [[ -n "${res_url:-}" ]]; then
    printf 'vpn_speed_result_url_info{name="%s",method="ookla",server="%s",server_location="%s",server_id="%s",url="%s"} 1\n' \
      "$NODE_NAME" "$srv_name" "$srv_loc" "$srv_id" "$res_url"
  fi

  if [[ -n "${dl_Bps:-}" || -n "${ul_Bps:-}" ]]; then
    printf 'vpn_speed_success{name="%s",method="ookla",server="%s"} 1\n' "$NODE_NAME" "$srv_name"
  else
    printf 'vpn_speed_success{name="%s",method="ookla"} 0\n' "$NODE_NAME"
  fi
} >>"$TMP"

# Атомарная запись без смены владельца (важно для User=node_exporter / UMask=0002)
install -m 0644 -T "$TMP" "$OUT"
